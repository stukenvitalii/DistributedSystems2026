# Лабораторная работа №4 — Репликация данных в распределённых системах

## Цель

Изучение принципов репликации данных в распределённых системах, анализ механизмов возникновения и разрешения конфликтов
при параллельных операциях записи с использованием модели ослабленной согласованности (eventual consistency).

## Архитектура решения

```
┌─────────────────────────────────────────────────────────────┐
│                    Distributed System                       │
│                                                             │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐               │
│  │  Node-A  │    │  Node-B  │    │  Node-C  │               │
│  │          │    │          │    │          │               │
│  │ store{}  │    │ store{}  │    │ store{}  │               │
│  │ clock{}  │    │ clock{}  │    │ clock{}  │               │
│  └────┬─────┘    └────┬─────┘    └────┬─────┘               │
│       │               │               │                     │
│       └───────────────┴───────────────┘                     │
│                  AsyncMessageBus                            │
│              (imitated delay 50–500ms)                      │
└─────────────────────────────────────────────────────────────┘
```

### Ключевые компоненты

| Компонент          | Описание                                                                                                                          |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| `VectorClock`      | Векторные часы. Хранят счётчик событий для каждого узла. Позволяют определить причинно-следственный порядок без глобальных часов. |
| `VersionedValue`   | Версионированное значение: `(value, vectorClock, authorId, wallTime)`                                                             |
| `ReplicaNode`      | Узел системы. Поддерживает локальное хранилище, операции `read`/`write`, приём репликаций.                                        |
| `AsyncMessageBus`  | Асинхронная шина сообщений. Имитирует сетевые задержки через Kotlin Coroutines.                                                   |
| `ConflictDetector` | Обнаруживает конкурентные (конфликтующие) версии по векторным часам.                                                              |
| `ConflictResolver` | Разрешает конфликты: LWW или Vector Clock Merge.                                                                                  |

## Алгоритмы

### Векторные часы (Vector Clocks)

Каждый узел хранит вектор `{nodeId → counter}`. При записи:

1. Счётчик своего узла инкрементируется.
2. При получении реплики — часы сливаются (`merge = max` по каждому компоненту).

Сравнение:

- `A < B` (BEFORE): все компоненты A ≤ B, хотя бы один строго меньше
- `A > B` (AFTER): все компоненты A ≥ B, хотя бы один строго больше
- `A ∥ B` (CONCURRENT): ни одно не доминирует — **конфликт**

### Разрешение конфликтов

**Last-Write-Wins (LWW):** Выбирается версия с наибольшим `wallTime`. Просто, но может приводить к потере данных.

**Vector Clock Merge:** Выбирается «победитель» по `wallTime`, но его векторные часы заменяются на объединение (`merge`)
всех конкурентных версий. Гарантирует, что будущие записи будут строго «после» всех предыдущих.

## Демонстрационные сценарии

| Сценарий | Описание                            | Ожидаемый результат                            |
|----------|-------------------------------------|------------------------------------------------|
| 1        | Последовательные записи             | Конфликтов нет, причинный порядок соблю дён    |
| 2        | Параллельные записи Node-A и Node-C | Конфликт на всех узлах после  реп      ликации |
| 3        | Разрешение конфликта                | Единственная версия , ч      асы объединены    |
| 4        | Три параллельных записи             | Тройной конфликт и его разрешение              |

## Сборка и запуск

```bash
# Сборка fat-jar
cd labs/lab4/replication-node
mvn package

# Запуск
java -jar target/replication-node-0.0.1-SNAPSHOT-all.jar
```

Или через Maven:

```bash
mvn -pl lab4/replication-node exec:java
```

## Тесты

```bash
cd labs/lab4/replication-node
mvn test
```

Тесты покрывают:

- `VectorClockTest` — операции increment, merge, compareTo (BEFORE/AFTER/CONCURRENT/EQUAL)
- `ConflictDetectorTest` — обнаружение конфликтов, фильтрация доминируемых версий
- `ConflictResolverTest` — стратегии LWW и Vector Clock Merge

## Выводы

1. **Leaderless replication + Eventual consistency** неизбежно порождают конфликты при параллельных записях на разные
   узлы.

2. **Векторные часы** позволяют точно определить причинно-следственный порядок событий без глобальной синхронизации
   времени.

3. **Last-Write-Wins** прост, но небезопасен — возможна потеря данных при конкуренции. Требует хотя бы приблизительно
   синхронизированных часов.

4. **Vector Clock Merge** семантически корректнее: объединённые часы гарантируют, что разрешённая версия «видит» все
   предыдущие конкурентные записи. Хорошо подходит для систем типа Amazon Dynamo.

5. Для production-систем предпочтительны: application-level merge (семантическое слияние данных) или предоставление всех
   версий клиенту для принятия решения.

